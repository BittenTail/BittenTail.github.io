<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BittenTail</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-24T05:22:13.489Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BittenTail</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux-链接</title>
    <link href="http://yoursite.com/2019/10/24/Linux-%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2019/10/24/Linux-链接/</id>
    <published>2019-10-24T03:05:59.000Z</published>
    <updated>2019-10-24T05:22:13.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux链接"><a href="#Linux链接" class="headerlink" title="Linux链接"></a>Linux链接</h1><hr><h5 id="在Linux中链接分为两种，一种为硬链接（Hard-Link），另外一种为软链接（Symbolic-Link）或称为符号链接。默认情况下，ln命令产生硬链接。"><a href="#在Linux中链接分为两种，一种为硬链接（Hard-Link），另外一种为软链接（Symbolic-Link）或称为符号链接。默认情况下，ln命令产生硬链接。" class="headerlink" title="在Linux中链接分为两种，一种为硬链接（Hard Link），另外一种为软链接（Symbolic Link）或称为符号链接。默认情况下，ln命令产生硬链接。"></a>在Linux中链接分为两种，一种为硬链接（Hard Link），另外一种为软链接（Symbolic Link）或称为符号链接。默认情况下，ln命令产生硬链接。</h5><a id="more"></a><hr><h2 id="硬链接："><a href="#硬链接：" class="headerlink" title="硬链接："></a>硬链接：</h2><p>硬链接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号（Inode Index），它存储着文件重要参数信息，也就是元数据（metadata），比如创建时间、修改时间、文件大小、属主、归属的用户组（属组）、读写权数据所在block号等。<br>在Linux中，多个文件名指向同一索引节点是存在的。比如：A是B的硬链接（A和B均为文件名），则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个。<br>硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的链接。只删除一个链接并不影响索引节点本身和其他的链接，只有当最后一个链接被删除后，文件的数据块及目录的链接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除。</p><hr><h2 id="软链接："><a href="#软链接：" class="headerlink" title="软链接："></a>软链接：</h2><p>软链接（符号链接），类似于windows系统中的快捷方式。它实际上是一种特殊的文件。在符号链接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A任然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><hr><h2 id="两者的特点"><a href="#两者的特点" class="headerlink" title="两者的特点"></a>两者的特点</h2><h3 id="软链接：-1"><a href="#软链接：-1" class="headerlink" title="软链接："></a>软链接：</h3><ul><li>1.软链接是存放另一个文件的路径的形式存在。</li><li>2.软链接可以跨文件系统，硬链接不行。</li><li>3.软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。</li><li>4.软链接可以对目录进行链接。</li></ul><h3 id="硬链接：-1"><a href="#硬链接：-1" class="headerlink" title="硬链接："></a>硬链接：</h3><ul><li>1.硬链接，以文件副本的形式存在。但不占用实际空间。</li><li>2.不允许给目录创建硬链接。</li><li>3.硬链接只有在同一个文件系统中才能创建。</li><li>4.删除一个硬链接文件并不影响其他有相同inode号的文件。</li></ul><p><strong>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁盘空间。</strong></p><p>Linux系统可以用ln命令来创建链接文件。</p><h5 id="ln命令格式："><a href="#ln命令格式：" class="headerlink" title="ln命令格式："></a>ln命令格式：</h5><p><strong>ln [参数] [源文件或目录] [目标文件或目录]</strong>   </p><h6 id="主要参数："><a href="#主要参数：" class="headerlink" title="主要参数："></a>主要参数：</h6><ul><li>-i交互模式，文件存在则提示用户是否覆盖。</li><li>-s软链接（符号链接）</li><li>-d允许超级用户制作目录的硬链接</li><li>-b删除，覆盖以前建立的链接<ul><li>软链接（符号链接）：ln -s source target</li><li>硬链接（实体链接）：ln source target</li></ul></li></ul><hr><blockquote><p>songguojun:<a href="https://www.cnblogs.com/songgj/p/9115954.html" target="_blank" rel="noopener">https://www.cnblogs.com/songgj/p/9115954.html</a></p></blockquote><hr><h3 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux链接&quot;&gt;&lt;a href=&quot;#Linux链接&quot; class=&quot;headerlink&quot; title=&quot;Linux链接&quot;&gt;&lt;/a&gt;Linux链接&lt;/h1&gt;&lt;hr&gt;&lt;h5 id=&quot;在Linux中链接分为两种，一种为硬链接（Hard-Link），另外一种为软链接（Symbolic-Link）或称为符号链接。默认情况下，ln命令产生硬链接。&quot;&gt;&lt;a href=&quot;#在Linux中链接分为两种，一种为硬链接（Hard-Link），另外一种为软链接（Symbolic-Link）或称为符号链接。默认情况下，ln命令产生硬链接。&quot; class=&quot;headerlink&quot; title=&quot;在Linux中链接分为两种，一种为硬链接（Hard Link），另外一种为软链接（Symbolic Link）或称为符号链接。默认情况下，ln命令产生硬链接。&quot;&gt;&lt;/a&gt;在Linux中链接分为两种，一种为硬链接（Hard Link），另外一种为软链接（Symbolic Link）或称为符号链接。默认情况下，ln命令产生硬链接。&lt;/h5&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"/>
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Redis初学</title>
    <link href="http://yoursite.com/2019/10/22/Redis%E5%88%9D%E5%AD%A6/"/>
    <id>http://yoursite.com/2019/10/22/Redis初学/</id>
    <published>2019-10-22T02:22:10.000Z</published>
    <updated>2019-10-22T03:02:14.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>Redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式。</li></ul><a id="more"></a><hr><h3 id="Redis数据类型："><a href="#Redis数据类型：" class="headerlink" title="Redis数据类型："></a>Redis数据类型：</h3><p>redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）以及zset（sorted set：有序集合）。</p><h4 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1.String（字符串）"></a>1.String（字符串）</h4><ul><li>String类型是二进制安全的。即Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</li><li>string类型的值最大能存储512MB。<h4 id="2-Hash（哈希）"><a href="#2-Hash（哈希）" class="headerlink" title="2.Hash（哈希）"></a>2.Hash（哈希）</h4></li><li>Redis hash是一个键值（key=&gt;value）对集合。</li><li>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</li><li>每个hash可以存储26</li></ul><hr><h2 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h2><ul><li>Redis配置文件：位于Redis安装目录下，文件名为rredis.conf（windows名为redis.windows.conf）。可以通过CONFIG命令查看或设置配置项。</li><li>守护进程（Daemon Process），即Daemon进程（精灵进程），是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。<br>守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在Linux中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依赖于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。·</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h2&gt;&lt;p&gt;Redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库&lt;/p&gt;&lt;h3 id=&quot;特点：&quot;&gt;&lt;a href=&quot;#特点：&quot; class=&quot;headerlink&quot; title=&quot;特点：&quot;&gt;&lt;/a&gt;特点：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2019/09/07/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/09/07/归并排序/</id>
    <published>2019-09-07T11:48:38.000Z</published>
    <updated>2019-09-07T11:59:09.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><a id="more"></a><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><h2 id="算法图解："><a href="#算法图解：" class="headerlink" title="算法图解："></a>算法图解：</h2><p><img src="/images/Blog/MergeSort/1.png" alt="avatar"></p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍：&quot;&gt;&lt;a href=&quot;#介绍：&quot; class=&quot;headerlink&quot; title=&quot;介绍：&quot;&gt;&lt;/a&gt;介绍：&lt;/h2&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="《算法导论》" scheme="http://yoursite.com/tags/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2019/09/06/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/09/06/插入排序/</id>
    <published>2019-09-06T14:05:55.000Z</published>
    <updated>2019-09-07T11:59:01.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>插入排序是将n个数的一个序列&lt;a1,a2,a3,…,an&gt;,经过插入排序算法将这n个数按序排列，输出满足a1&lt;a2&lt;a3&lt;…&lt;an。</p><a id="more"></a><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>插入算法的工作方式如同人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入到左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较，并进行插入。拿在手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。</p><h2 id="算法图解："><a href="#算法图解：" class="headerlink" title="算法图解："></a>算法图解：</h2><p><img src="/images/Blog/InsertionSort/1.png" alt="avatar"></p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int [] insertSort(int [] nums) &#123;</span><br><span class="line">int key=0,j;</span><br><span class="line">for(int i=1;i&lt;nums.length;i++) &#123;</span><br><span class="line">key = nums[i];</span><br><span class="line">j = i-1;</span><br><span class="line">while(j &gt;= 0 &amp;&amp; nums[j] &gt; key) &#123;//当j到达第一个数时，或者插入值找到位置时退出循环</span><br><span class="line">nums[j+1] = nums[j];</span><br><span class="line">j = j-1;</span><br><span class="line">&#125;</span><br><span class="line">nums[j+1] = key;</span><br><span class="line">&#125;</span><br><span class="line">return nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍：&quot;&gt;&lt;a href=&quot;#介绍：&quot; class=&quot;headerlink&quot; title=&quot;介绍：&quot;&gt;&lt;/a&gt;介绍：&lt;/h2&gt;&lt;p&gt;插入排序是将n个数的一个序列&amp;lt;a1,a2,a3,…,an&amp;gt;,经过插入排序算法将这n个数按序排列，输出满足a1&amp;lt;a2&amp;lt;a3&amp;lt;…&amp;lt;an。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="插入排序" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="《算法导论》" scheme="http://yoursite.com/tags/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="http://yoursite.com/2019/09/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/09/06/我的第一篇博客/</id>
    <published>2019-09-06T01:05:53.000Z</published>
    <updated>2019-09-06T01:47:22.096Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="My" scheme="http://yoursite.com/tags/My/"/>
    
  </entry>
  
</feed>
