{"meta":{"title":"BittenTail","subtitle":null,"description":null,"author":"BittenTail","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-09-06T01:42:40.000Z","updated":"2019-09-06T01:44:32.239Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-09-04T08:26:11.000Z","updated":"2019-09-04T08:31:22.337Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-04T08:24:15.000Z","updated":"2019-09-04T08:31:36.919Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"二叉树的创建与遍历","slug":"二叉树的创建与遍历","date":"2019-12-09T13:31:03.000Z","updated":"2019-12-09T13:57:51.083Z","comments":true,"path":"2019/12/09/二叉树的创建与遍历/","link":"","permalink":"http://yoursite.com/2019/12/09/二叉树的创建与遍历/","excerpt":"二叉树的结构定义 使用Java进行二叉树的建立与遍历","text":"二叉树的结构定义 使用Java进行二叉树的建立与遍历 class TreeNode{int val; TreeNode left; TreeNode right; TreeNode(int x){val = x;} } 二叉树的建立 利用栈进行先序创建二叉树 //利用栈先序创建二叉树 TreeNode creatTree(List&lt;Integer&gt; nums) { Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode root = null; TreeNode parent = null; boolean lIsNull = false; TreeNode p = null; for(Integer i:nums) { //判断是否已经创建完根节点 if(root == null) { p = new TreeNode(i); root = p; parent = p; stack.push(p); }else if(i != null) { //输入的节点为null p = new TreeNode(i); if(lIsNull) { //创建完左孩子，且为null parent.right = p; parent = p; lIsNull = false; }else {//未创建左孩子 parent.left = p; parent = p; } stack.push(p); }else { if(lIsNull) {//左孩子为空，且右孩子也为空 if(stack.isEmpty()) {//如果栈为空，便是最后一个节点 return root; }else {// 返回为为空节点的双亲的双亲 parent = stack.pop(); } }else {//节点为空，令左孩子为null，返回为其双亲， //且使标记lIsNull为true，表示左孩子为空 parent = stack.pop(); lIsNull = true; } } } return root; }先序遍历二叉树 使用递归 /* * 二叉树的先序遍历 */ //使用递归先序遍历二叉树 public void preOrderTraverse1(TreeNode root) { if(root != null) { System.out.print(root.val); preOrderTraverse1(root.left); preOrderTraverse1(root.right); } } 使用栈 //使用栈先序遍历二叉树 public void preOrderTraverse2(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode p = root; while(p != null || !stack.isEmpty()) { if(p != null) { System.out.print(p.val); stack.push(p); p = p.left; }else { p = stack.pop(); p = p.right; } } }中序遍历二叉树 使用递归 /* * 二叉树的中序遍历 */ //使用递归进行中序遍历二叉树 public void inOrderTraverse1(TreeNode root) { if(root != null) { inOrderTraverse1(root.left); System.out.print(root.val); inOrderTraverse1(root.right); } } 使用栈 //使用栈进行中序遍历二叉树 public void inOrderTraverse2(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while(root != null || !stack.isEmpty()) { if(root != null) { stack.push(root); root = root.left; }else { root = stack.pop(); System.out.print(root.val); root = root.right; } } }中序遍历二叉树 使用递归 /* * 二叉树的后序遍历 */ //使用递归进行后序遍历二叉树 public void postOrderTraverse1(TreeNode root) { if(root != null) { postOrderTraverse1(root.left); postOrderTraverse1(root.right); System.out.print(root.val); } } 使用栈 //使用栈进行后序遍历二叉树 public void postOrderTraverse2(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while(root != null || !stack.isEmpty()) { if(root != null) { //使每个节点入栈两个，从而达到后序输出根节点 stack.push(root); stack.push(root); root = root.left; }else { root = stack.pop(); //根据栈顶元素判断是遍历弹栈还是输出根节点弹栈 if(!stack.isEmpty() &amp;&amp; root.val == stack.peek().val){ root = root.right; }else { System.out.print(root.val); root = null; } } } }层次（广度）遍历","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/二叉树/"}]},{"title":"哈夫曼编码","slug":"哈夫曼编码","date":"2019-11-23T01:24:47.000Z","updated":"2019-12-09T13:35:38.487Z","comments":true,"path":"2019/11/23/哈夫曼编码/","link":"","permalink":"http://yoursite.com/2019/11/23/哈夫曼编码/","excerpt":"哈夫曼编码哈夫曼编码可以很有效地压缩数据：通常可以节省20%~90%的空间，具体压缩率依赖于数据的特性。","text":"哈夫曼编码哈夫曼编码可以很有效地压缩数据：通常可以节省20%~90%的空间，具体压缩率依赖于数据的特性。 哈夫曼编码 假定我们希望压缩一个十万个字符的数据文件，下表给出了文件中所出现的字符和他们所出现的频率。 a b c d e f 频率（千次） 45 13 12 16 9 5 定长编码 000 001 010 011 100 101 变长编码 0 101 100 111 1101 1100 采用一种二进制字符编码，每个字符用一个唯一的二进制串表示，称为码字。 定长编码：需要用3位来表示6个字符，如上表定长编码所示，这种方式需要300000个二进制位来编码文件。 变长编码（variable-length code）：可以达到比定长编码好得多的压缩率，其思想是赋予高频字符短码字，赋予低频字符长码字。如上表变长编码所示。，这种编码表示共需224000位，比定长编码节约了25%的空间。 前缀码(prefix code）：即没有任何码字是其他码字的前缀。前缀码的作用是简化解码过程。由于没有码字是其他码字的前缀，编码文件的开始码字是无歧义的。我们可以简单的识别出开始码字，将其转换回原字符，然后对编码文件剩余部分重复这种解码过程。 哈夫曼树前缀码的一种方便的表示形式，可以容易地截取开始码字。一种二叉树，其叶节点为给定的字符。字符的二进制码字用从根节点到该字符叶节点的简单路径表示，其中0意味着“转向左孩子”，1意味着“转向右孩子”。注意：编码树并不是二叉搜索树，因为叶节点并未有序排列，而内部节点并不包含字符关键字。mermaid graph TB client--&gt;|2 findConfigServices|LoadBalancer; LoadBalancer--&gt;|3 findService|metaServer; metaServer--&gt;Eureka; client--&gt;|4 access via ip:port/client load balance/error retry|ConfigService; ConfigService--&gt;|1 register/cancel|Eureka; ConfigService--&gt;|read/write|ConfigDB;​","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"哈夫曼编码","slug":"哈夫曼编码","permalink":"http://yoursite.com/tags/哈夫曼编码/"}]},{"title":"Java杂记","slug":"Java杂记","date":"2019-11-17T11:23:19.000Z","updated":"2019-12-09T13:36:17.355Z","comments":true,"path":"2019/11/17/Java杂记/","link":"","permalink":"http://yoursite.com/2019/11/17/Java杂记/","excerpt":"操作符指数记数法 1.39E-43：其中e并不代表自然对数的基数（约等于2.718），而是“10的幂次”。","text":"操作符指数记数法 1.39E-43：其中e并不代表自然对数的基数（约等于2.718），而是“10的幂次”。 移位操作符 移位操作符的运算对象是二进制的“位”。 移位操作符只可用来处理整数类型（基本类型的一种）。 左移位操作符（&lt;&lt;）：能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0） 有符号”右移位操作符（&gt;&gt;）：按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。 Java中增加了一种“无符号”右移位操作符（&gt;&gt;&gt;），它使用“零扩展”：无论正负，都在高位插入0。这一操作符在C或C++中是没有的。 如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，他们会被转换为int类型，并且得到的结果也是一个int类型的值。只有数值右端的低5位才有用，这样可防止我们移位超过int型值所具有d额位数。（译注：因为2的5次方为32，而int型值只有32位）若对一个long类型的数值进行处理，最后得到的结果也是long。此时只会用到数值右端的低6位，以防止移位超过long型数值具有的位数。 “移位”可与“等号”（&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=）组合使用。注意：如果对byte或short值进行这样的移位运算，得到的可能不是正确的结果，他们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"操作符","slug":"操作符","permalink":"http://yoursite.com/tags/操作符/"}]},{"title":"数据库查询语句-select","slug":"数据库查询语句-select","date":"2019-11-11T07:50:15.000Z","updated":"2019-11-12T10:01:10.663Z","comments":true,"path":"2019/11/11/数据库查询语句-select/","link":"","permalink":"http://yoursite.com/2019/11/11/数据库查询语句-select/","excerpt":"查询SELECT（select）","text":"查询SELECT（select） 1.为表起别名（建议不要起中文）select * from 表名 as 别名 --》as可以省略 select 表名.列名1 列名2 from 表名2.查询全部列（*），指定列（列名），为列起别名as3.查询前n部分数据： top n 列名：表示查看前n行 select top 1 * from 表名 --》查询第一行 top n percent 列名：表示查看前百分之n的数据 selsct top 2 percent * from 表名 --》查询前2%的行4.排序：order by 列名1 asc|desc，列名1 asc|desc、、、(asc-升序|desc-降序)selsct top 2 percent * from 表名 order by 列名1 asc，列名2 desc --》先以列1按升序排，相同的再按列2按降序排 消除重复行：distinct select distinct 列名 from 表名 --》需要将列隔开，而不是利用*针对所有列 5.条件查询：写在where后面 对行进行筛选，返回bool类型的值 比较运算符：=，&gt;，&gt;=，&lt;，&lt;=，!=，&lt;&gt; select 列名 from 表名 where 列名=条件 between…and…：表示在一个连续的范围内 --取出编号从3-8的数据 select * from 表名 where 列名 between 3 and 8 in：表示在一个非连续的范围内 --取出编号为1或3的数据 select * from 表名 where 列名 in（1,3） 逻辑运算符：and，or，not 模糊查询：用于处理字符串类型的值，运算符包括（类似于正则表达式）：“like”(关键字) “%”(表示0到多个字符) “_” （表示一个字符）“[]”（表示从一个范围内选一个字符） “^”。 “%”与“_”写在“[]”中表示本身的含义在“[]”表示一个连续的范围可以使用“-”“^”写在“[]”内部的开头，表示不使用内部的任何字符。 --姓名为张的数据 select * from 表名 where name like &apos;张%&apos; null的判断：使用is null或is not null --列1为null的数据 select * from 表名 where 列1 is （not） null 优先级：小括号&gt;not&gt;比较运算符&gt;逻辑运算符 6.连接：join 表名 on 关联条件（连接查询：当需要的结果从多张表中取时） 左表 …join 右表 内连接：innew join，两表中完全匹配的数据。 select * from 表1 as 别名1 ` inner join 表2 as 别名2 on 别名1.列1=别名2.列1 左外连接：left outer join，两表中完全匹配的数据，左表中特有的数据。 右外连接：right outer join，两表中完全匹配的数据，右表中特有的数据。 完全外连接：full outer join，两表中完全匹配的数据，左表中特有的数据，右表中特有的数据。 -关键问题：哪些表行，关系 7.聚合函数：对数据进行合并。 sum（求和） avg（平均） count（计数) max（最大） min（最小）一般是对数字类型的列进行操作一条查询中可以同时写多个聚合函数，但是不能与普通列混写聚合中的null问题：不参与计算 select COUNT（*） as count from 表名 （where 列名=条件）8.开窗函数over（）将统计出来的数据分布到原表的每一行中结合聚合函数、排名函数使用 --将统计信息分布到每一行中去 select * avg(列名） over（） from 表名9.分组group by 列名1 列名2…聚合函数一般结合分组使用，进行分组内的数据进行统计根据指定列进行分组分组后条件筛选：having… --统计男女生人数 select 列名1 count（*） --》只能显示分组那一列 from 表名 where 列名1=条件 --》where语句写在分组前 group by 列名1 --》可以进行多级分组，只需在后面加“,列名2...” having count（*）&gt;条件 --》对分组之后的数据进行筛选总结：完整的select语句及执行顺序select distinct top n * from 表名1 join 表名2 on...join..表名n.. where ... group by...having... oder by...","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"},{"name":"查询","slug":"查询","permalink":"http://yoursite.com/tags/查询/"}]},{"title":"Java Virtual Machine-自动内存管理机制（内存区域）","slug":"Java Virtual Machine-自动内存管理机制（内存区域）","date":"2019-11-11T07:50:15.000Z","updated":"2019-11-14T14:06:39.086Z","comments":true,"path":"2019/11/11/Java Virtual Machine-自动内存管理机制（内存区域）/","link":"","permalink":"http://yoursite.com/2019/11/11/Java Virtual Machine-自动内存管理机制（内存区域）/","excerpt":"概述与C/C++不同，Java拥有虚拟机自动内存管理机制，不需要为new的每一个对象都去写向对应的delect/free，从而不容易出现内存泄露和内存溢出问题。不过，也因Java程序员将内存控制的权利交给了Java虚拟机，一旦出现内存泄露和溢出的问题，如果不了解虚拟机是如何使用内存的，那么将很难排查错误。","text":"概述与C/C++不同，Java拥有虚拟机自动内存管理机制，不需要为new的每一个对象都去写向对应的delect/free，从而不容易出现内存泄露和内存溢出问题。不过，也因Java程序员将内存控制的权利交给了Java虚拟机，一旦出现内存泄露和溢出的问题，如果不了解虚拟机是如何使用内存的，那么将很难排查错误。 Java运行时数据区 由线程共享的数据区 线程隔离的数据区 方法区（Method Area) 虚拟机栈（VM Stack） 堆（Heap） 本地方法栈（Native Method Stack） 程序计数器（Program Counter Register） 程序计数器（Program Counter Register）线程私有的 定义：程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。 作用：由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，因此在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。所以为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，且各线程之间计数器互不影响，独立存储，我们称这片内存区域为“线程私有”的内存。 线程计数器：线程正在执行一个Java方法—-》计数器记录的是正在执行的虚拟机字节码指令的地址。线程正在执行一个Native方法–》计数器值为空（Undefined） 注：此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈（Java Virtual Machine Stack）线程私有的 生命周期与线程相同。 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表：存放了编译期可知的各种基本数据类型（boolean、byte、short、int、long、float、double、char）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用两个局部变量空间（Slot），其余的数据类型只占用一个。 局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。PS：栈帧：是方法运行时的基础数据结构。 注：会抛出StackOverflowError异常，如果扩展时无法申请到足够的内存，就会抛出会抛出OutOfMemoryError异常。 本地方法栈（Native Method Stack）线程私有的本地方法栈所发挥的作用与虚拟机栈的作用非常相似。两者之间的区别： 虚拟机栈：为虚拟机执行Java方法（也就是字节码）服务 本地方法栈：为虚拟机使用到的Native方法服务虚拟机规范中并未对本地方法栈中方法使用的语言、使用方式与数据结构进行强制规定，因此具体的虚拟机可以自由实现它。 如Sun HotSpot虚拟机直接将本地方法栈与虚拟机栈合二为一。 注：与虚拟机栈一样，也会抛出StackOverflowError异常和OutOfMemoryError异常。 Java堆（Java Heap）线程共享的 是Java虚拟机所管理的内存中最大的一块，在虚拟机启动时创建。 唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配。Java虚拟机规范中的描述：The heap is the runtime data area from which memory for all class instances and arrays is allocated.(所有的对象实例及数组都要在对上分配。）不过随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。 Java堆根据收集器所使用的的分代收集算法，还可进行分类，如新生代、老生代等。 Java堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可。 注：如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区（Method Area)线程共享的 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 垃圾收集较少，内存回收目标主要是针对常量池的回收和对类型的卸载。 注：当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。运行时常量池（Runtime Constant Pool） 方法区的一部分 Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 具备动态性，运行期间也可能将新的常量放入池中，如String类的intern（）方法。 注：当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域 这部分内存也被频繁使用，并且也可能导致OutOfMemoryError异常。 不会受到Java堆大小的限制。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"内存","slug":"内存","permalink":"http://yoursite.com/tags/内存/"}]},{"title":"数据库脚本操作","slug":"数据库脚本操作","date":"2019-11-08T08:48:36.000Z","updated":"2019-11-12T06:02:11.897Z","comments":true,"path":"2019/11/08/数据库脚本操作/","link":"","permalink":"http://yoursite.com/2019/11/08/数据库脚本操作/","excerpt":"脚本操作","text":"脚本操作 不区分大小写，字符串使用单引号，末尾不需要加分号 按照功能分类 DDL：数据定义语言，用于进行各种数据库对象的创建，主要操作包括create（创建）、alter（修改）、drop（删除）。 DML：数据管理语言，用于对表数据的添加、修改、删除、查询，主键操作包括insert（插入）、update（修改）、delete(删除）、select（查询）。 DCL：数据控制语言，用于进行权限分配等。 注释：–单行注释，/**/多行注释 数据库：创建、删除 可以通过查看master数据库中的sysdatabases表，来了解当前存在的数据库。 创建数据库create database 数据库名 on primary ( name=&apos;stuDB_data&apos;,--主数据文件的逻辑名称 filename=&apos;D:\\stuDB_data.mdf&apos;,--主数据文件的物理名称 size=5mb,--主数据文件的初始大小 maxsize=100mb,--主数据文件增长的最大值 filegrowth=15%--主数据文件的增长率 ) log on ( name=&apos;stuDB_log&apos;, filename=&apos;D:\\stuDB_log.ldf;, size=2mb, filegrowth=1mb )创建表use 数据库名 create table 表名 ( 列名 int not null primary key identity(1,1), 列名 nvarchar(10) )","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"脚本语法","slug":"脚本语法","permalink":"http://yoursite.com/tags/脚本语法/"}]},{"title":"数据库语句学习","slug":"数据库语句学习","date":"2019-11-07T07:34:52.000Z","updated":"2019-11-12T06:02:28.280Z","comments":true,"path":"2019/11/07/数据库语句学习/","link":"","permalink":"http://yoursite.com/2019/11/07/数据库语句学习/","excerpt":"SQL基本命令","text":"SQL基本命令 SELECT(select)：查看数据库中的数据。 UPDATA（updata）：更新数据库中的数据。 DELETE（delect）：从数据库中删除数据。 INSERT INTO(insert into)：向数据库中插入新数据。 CREATE DATABASE(create database）：创建新数据库。 ALTER DATABASE(alter database）：修改数据库。 CREATE TABLE(create Table）：创建新表。 ALTER TABLE(alter Table）：变更数据库表。 DROP TABLE(drop table）：删除表。 CREATE INDEX(create index）：创建索引（搜索键）。 DROP INDEX(drop index）：删除索引。 示例数据库student表： id name score 1 张三 60 2 李四 60 3 王五 61 4 小六 62 1.SELECT（select）语句：显示某几列的数据： SELECT column_name,column_name FROM table_name; SELECT name,score FROM student;以及显示表中的全部列的数据： SELECT * FROM table_name; SELECT * FROM student;SELECT DISTINCT:返回唯一不同的值（所有有重复的项只会返回一个值）。 SELECT DISTINCT column_name，column_name FROM table_name； SELECT DISTINCT score FROM student;2.WHERE(where）语句：用于提取（筛选）那些满足指定条件的记录。 SELECT column_name,column_name FROM table_name WHERE column_name operator value;利用WHERE语句从student表中选取姓名为张三的所有学生： SELECT * FROM Websites WHERE name=&apos;张三&apos;;WHERE语句中的运算符： 运算符 描述 = 等于 &lt;&gt; 不等于。注释：在SQL的一些版本中，该操作符可被写成！= &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 is null 空值判断 BETWEEN 在某个范围内 LIKE 搜索某种模式（正则表达式） IN 指定针对某个列的多个可能值 PS:文本字段&amp;数值字段：SQL使用单引号来环绕文本值（大部分数据库系统也接收双引号），上述代码中使用了单引号。如果是数值字段，则不用使用引号。###","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"Linux-链接","slug":"Linux-链接","date":"2019-10-24T03:05:59.000Z","updated":"2019-12-09T13:35:20.103Z","comments":true,"path":"2019/10/24/Linux-链接/","link":"","permalink":"http://yoursite.com/2019/10/24/Linux-链接/","excerpt":"Linux链接在Linux中链接分为两种，一种为硬链接（Hard Link），另外一种为软链接（Symbolic Link）或称为符号链接。默认情况下，ln命令产生硬链接。","text":"Linux链接在Linux中链接分为两种，一种为硬链接（Hard Link），另外一种为软链接（Symbolic Link）或称为符号链接。默认情况下，ln命令产生硬链接。 硬链接：硬链接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号（Inode Index），它存储着文件重要参数信息，也就是元数据（metadata），比如创建时间、修改时间、文件大小、属主、归属的用户组（属组）、读写权数据所在block号等。在Linux中，多个文件名指向同一索引节点是存在的。比如：A是B的硬链接（A和B均为文件名），则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的链接。只删除一个链接并不影响索引节点本身和其他的链接，只有当最后一个链接被删除后，文件的数据块及目录的链接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除。 软链接：软链接（符号链接），类似于windows系统中的快捷方式。它实际上是一种特殊的文件。在符号链接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A任然存在（因为两个是不同的文件），但指向的是一个无效的链接。 两者的特点软链接： 1.软链接是存放另一个文件的路径的形式存在。 2.软链接可以跨文件系统，硬链接不行。 3.软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。 4.软链接可以对目录进行链接。 硬链接： 1.硬链接，以文件副本的形式存在。但不占用实际空间。 2.不允许给目录创建硬链接。 3.硬链接只有在同一个文件系统中才能创建。 4.删除一个硬链接文件并不影响其他有相同inode号的文件。 不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁盘空间。 Linux系统可以用ln命令来创建链接文件。 ln命令格式：ln [参数] [源文件或目录] [目标文件或目录] 主要参数： -i交互模式，文件存在则提示用户是否覆盖。 -s软链接（符号链接） -d允许超级用户制作目录的硬链接 -b删除，覆盖以前建立的链接 软链接（符号链接）：ln -s source target 硬链接（实体链接）：ln source target songguojun:https://www.cnblogs.com/songgj/p/9115954.html PS：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"链接","slug":"链接","permalink":"http://yoursite.com/tags/链接/"}]},{"title":"Redis初学","slug":"Redis初学","date":"2019-10-22T02:22:10.000Z","updated":"2019-11-12T06:03:28.912Z","comments":true,"path":"2019/10/22/Redis初学/","link":"","permalink":"http://yoursite.com/2019/10/22/Redis初学/","excerpt":"简介：","text":"简介： Redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库 特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式。 Redis数据类型：redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）以及zset（sorted set：有序集合）。 1.String（字符串） String类型是二进制安全的。即Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。 string类型的值最大能存储512MB。2.Hash（哈希） Redis hash是一个键值（key=&gt;value）对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 每个hash可以存储26 PS： Redis配置文件：位于Redis安装目录下，文件名为rredis.conf（windows名为redis.windows.conf）。可以通过CONFIG命令查看或设置配置项。 守护进程（Daemon Process），即Daemon进程（精灵进程），是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在Linux中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依赖于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。·","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"归并排序","slug":"归并排序","date":"2019-09-07T11:48:38.000Z","updated":"2019-11-12T06:03:01.248Z","comments":true,"path":"2019/09/07/归并排序/","link":"","permalink":"http://yoursite.com/2019/09/07/归并排序/","excerpt":"介绍：","text":"介绍： 描述：算法图解： 代码实现：12","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"插入排序","slug":"插入排序","date":"2019-09-06T14:05:55.000Z","updated":"2019-11-12T06:03:17.865Z","comments":true,"path":"2019/09/06/插入排序/","link":"","permalink":"http://yoursite.com/2019/09/06/插入排序/","excerpt":"介绍：","text":"介绍： 插入排序是将n个数的一个序列&lt;a1,a2,a3,…,an&gt;,经过插入排序算法将这n个数按序排列，输出满足a1&lt;a2&lt;a3&lt;…&lt;an。 描述：插入算法的工作方式如同人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入到左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较，并进行插入。拿在手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。 算法图解： 代码实现：12345678910111213public int [] insertSort(int [] nums) &#123; int key=0,j; for(int i=1;i&lt;nums.length;i++) &#123; key = nums[i]; j = i-1; while(j &gt;= 0 &amp;&amp; nums[j] &gt; key) &#123;//当j到达第一个数时，或者插入值找到位置时退出循环 nums[j+1] = nums[j]; j = j-1; &#125; nums[j+1] = key; &#125; return nums; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-09-06T01:05:53.000Z","updated":"2019-09-06T01:47:22.096Z","comments":true,"path":"2019/09/06/我的第一篇博客/","link":"","permalink":"http://yoursite.com/2019/09/06/我的第一篇博客/","excerpt":"","text":"","categories":[],"tags":[{"name":"My","slug":"My","permalink":"http://yoursite.com/tags/My/"}]}]}