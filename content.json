{"meta":{"title":"BittenTail","subtitle":null,"description":null,"author":"BittenTail","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-09-04T08:26:11.000Z","updated":"2019-09-04T08:31:22.337Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-04T08:24:15.000Z","updated":"2019-09-04T08:31:36.919Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-09-06T01:42:40.000Z","updated":"2019-09-06T01:44:32.239Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"HashMap、HashTable和ConcurrentMap","slug":"HashMap、HashTable和ConcurrentMap","date":"2020-03-10T04:26:21.000Z","updated":"2020-03-10T04:35:04.972Z","comments":true,"path":"2020/03/10/HashMap、HashTable和ConcurrentMap/","link":"","permalink":"http://yoursite.com/2020/03/10/HashMap、HashTable和ConcurrentMap/","excerpt":"","text":"HashMap、HashTable和ConcurrentMap","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/tags/Java集合/"}]},{"title":"Java面试知识点链接合集","slug":"Java面试知识点链接合集","date":"2020-03-07T10:02:30.000Z","updated":"2020-03-18T08:49:45.523Z","comments":true,"path":"2020/03/07/Java面试知识点链接合集/","link":"","permalink":"http://yoursite.com/2020/03/07/Java面试知识点链接合集/","excerpt":"Java面试总结归纳1.HashMap、HashTable和ConcurrentMap我的总结点击此处跳转面试题：Hashmap和ConcurrentMap的区别，HashMap的底层源码","text":"Java面试总结归纳1.HashMap、HashTable和ConcurrentMap我的总结点击此处跳转面试题：Hashmap和ConcurrentMap的区别，HashMap的底层源码 点击此处跳转 面试必备：HashMapHashTable、Concurrentmap的原理与区别 点击此处跳转 HashMap与ConcurrentHashMap工作原理、区别和总结其中有随jdk版本的改变 点击此处跳转 2.volatile、sychronized和lock以及atomic类volatilevolatile整理并发机制底层实现整理 sychronizedsychronized的使用 lockLock锁底层原理 atomic类atomic详解CAS操作深入浅出CAS sychronized和volatile的区别点击此处跳转点击此处跳转 sychronized和Lock的区别点击此处跳转sychronized和Lock比较详解","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"链接合集","slug":"链接合集","permalink":"http://yoursite.com/tags/链接合集/"}]},{"title":"Java类型信息","slug":"Java类型信息","date":"2020-01-13T11:35:16.000Z","updated":"2020-01-13T11:37:37.616Z","comments":true,"path":"2020/01/13/Java类型信息/","link":"","permalink":"http://yoursite.com/2020/01/13/Java类型信息/","excerpt":"第十四章 类型信息 运行时类型信息使得你可以在程序运行时发现和使用类型信息它使你从只能在编译期执行面向类型的操作的禁锢中解脱了出来，并且可以使用某些非常强大的程序。对RTTI（Run-Time Type Identification——运行时类型识别）的需要，揭示了面向对象设计中许多有趣（并且复杂）的问题，同时也提出了如何组织程序得人问题。Java是如何让我们在运行时识别对象和类的信息的。主要有两种方式：","text":"第十四章 类型信息 运行时类型信息使得你可以在程序运行时发现和使用类型信息它使你从只能在编译期执行面向类型的操作的禁锢中解脱了出来，并且可以使用某些非常强大的程序。对RTTI（Run-Time Type Identification——运行时类型识别）的需要，揭示了面向对象设计中许多有趣（并且复杂）的问题，同时也提出了如何组织程序得人问题。Java是如何让我们在运行时识别对象和类的信息的。主要有两种方式： 一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型； 另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。14.1 为什么需要RTTI 插入代码，J-P-313 在上述例子中，当把Shape对象放入List的数组时会向上转型。但在向上转型为Shape的时候也丢失了Shape对象的具体类型。对于数组而言，它们只是Shape类的对象。当从数组中取回元素是，这种容器——实际上它将所有的事物都当做Object持有——会自动将结果转型会Shape。这是RTTI最基本的使用形式，因为在Java中，所有的类型转换都是在运行时进行正确性检查的。这也是RTTI名字的含义：在运行时，识别一个对象的类型。多态机制：你希望大部分代码尽可能少地了解对象的具体类型，而是只与对象家族中的一个通用表示打交道（上例中是基类Shape）。这样的代码会更容易编写，更容易读，且更便于维护；设计也更容易实现、理解和改变。-》但是，假如你碰到一个特殊的编程问题——如果能够知道某个泛化引用的确切类型，就可以使用最简单的方式去解决它，那么此时该怎么办呢？假如：可能要用某个方法来旋转列出的所有图形，但想跳过圆形，因为对圆形旋转没有意义。-》使用RTTI。可以查询某个Shape引用所指向的对象的确切类型，然后选择或者剔除特例。 14.2 Class对象要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的。这项工作是由称为Class对象 的特殊对象完成的，它包含了与类有关的信息。事实上，Class对象就是用来创建类的所有的“常规”对象的。Java使用Class对象类执行其RTTI，即使你正在执行的是类似转型这样的操作。Class类还拥有大量的使用RTTI的其他方式。==类是程序的一部分，每个类都有一个Class对象。==换言之，每当编写并且编译了一个新类，就会产生一个Class对象（更恰当地说，是被保存在一个同名的.class文件中）。为了生存这个类的对象，运行这个程序的Java虚拟机（JVM）将使用被称为“类加载器”的子系统。类加载器子系统实际上可以包含一条类加载器链，但是只有一个 原生类加载器，它是JVM实现的一部分。原生类加载器加载的是所谓的 可信类，包括Java API类，它们通常是从本地盘加载的。在这条链中，通常不需要添加额外的类加载器，但是如果你有特殊需求（例如以某种特殊的方式加载类中，以支持Web服务器应用，或者在网络中下载类），那么你有一种方式可以挂接额外的类加载器。所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用是，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用 static 关键字。因此，使用 new 操作符创建类的新对象也会被当做对类的静态成员的引用。因此，Java程序在它开始运行之前并非被完全加载，其各个部分是在必需时才加载的。这一点与许多传统语言都不同。动态加载使能的行为，在诸如C++这样的静态加载语言中是很难或者根本不可能复制的。类加载器首先检查这个类的Class对象是否已将加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件（例如，某个附加类加载器可能会在数据库中查找字节码）。在这个类的字节码被加载时，它们会接收验证，以确保其没有被破坏，并且不包含不良Java代码（这是Java中用于安全防范目的的措施之一）。一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。 例子：代码，J-P-315 Class.forName(&quot;全限定名&quot;)这个方法是Class类（所有Class对象都属于这个类）的一个static成员。Class对象就和其他对象一样，我们可以获取并操作它的引用（这也就是类加载器的工作）。forName()是取得Class对象的引用的一种方法。它是用一个包含目标类的文本名（注意拼写和大小写）的String做输入参数，返回的是一个Class对象的引用，上面的代码忽略了返回值。对forName()的调用是为了它产生的“副作用”：如果类X还没有被加载就加载它。无论何时，只要你想在运行时使用类型信息，就必须首先获得对恰当的Class对象的引用。Class.forName()就是实现此功能的便捷途径，因为你不需要为了获得Class引用而持有该类型的对象。但是，如果你已经拥有了一个感兴趣的类型的对象，那就可以通过调用getClass()方法来获取Class引用了，这个方法属于根类Object的一部分，它将返回表示该对象的实际类型的Class引用。Class包含很多有用的方法，下面是其中的一部分： 代码：J-P-316，317 14.2.1 类字面常量Java还提供了另一种方法来生成对Class对象的引用，即使用 类字面常量。对上述代码来说，就像这样：FancyToy.class这样做不仅更简单，而且更加安全，因为它在编译时就会受到检查（因此不需要置于try语句块中）。并且它根除了对forName()方法的调用，所以也更高效。类字面常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装器类，还有一个标准字段TYPE。TYPE字段是一个引用，指向对应的基本数据类型的Class对象。建议使用“.class”的形式，以保持与普通类的一致性。**注意，有一点很有趣，当使用“.class”来创建对Class对象的引用时，不会自动地初始化该Class对象。为了使用类而做的准备工作实际包含三个步骤： 加载，这是由类加载器执行的。该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个Class对象。 链接。在链接节点将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。 初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行： 代码：J-P-319 初始化有效地实现了尽可能的“惰性”。从对initable引用的创建中可以看到，仅使用.class语法来获得对类的引用不会引发初始化。但是，为了产生Class引用，Class.forName()立即就进行了初始化，就像在对initable3引用的创建中所看到的。如果一个static final值是“编译期常量”，就像Initable.staticFinal那样，那么这个值不需要对Initable类进行初始化就可以被读取。但是，如果只是将一个域设置为static和final的，还不足以确保这种行为，例如，对Initable.staticFinal2的访问将强制进行累的初始化，因为它不是一个编译期常量。如果一个static域不是final的，那么在对它访问时，总是要求在它被读取之前，要先进行链接（为这个域分配存储空间）和初始化（初始化该存储空间），就像在对Initable2.staticNonFinal的访问中所看到的那样。 14.2.2 泛化的Class引用Class引用总是指向某个Class对象，它可以制造类的实例，并包含可作用于这些实例的所有方法代码。它还包含该类的静态成员，因此，Class引用表示的就是它所指向的对象的确切类型，而该对象便是Class类的一个对象。 代码：J-P-320 普通的类引用不会产生警告信息，你可以看到，尽管泛型类引用只能赋值为指向其声明的类型，但是普通的类引用可以被重新赋值为指向任何其他的Class对象。通过使用泛型语法，可以让编译器强制执行额外的类型检测。如果你希望稍微放松一些这种限制，应该怎么办呢？乍一看，好像你应该能够执行类似下面这样的操作：Class genericNumberClass = int.class这看起来似乎是起作用的，因为Integer继承自Number。但是它无法工作，因为Integer Class对象不是Number Class对象的子类（这种差异看起来可能有些诡异，我们将在第15章中深入讨论它）。为了使用泛化的Class引用时放松限制，可以使用通配符，它是Java泛型的一部分。通配符就是“？”，表示“任何事物”。为了创建一个Class引用，它被限定为某种类型，或该类型的任何子类型，你需要将通配符与extends关键字向结合，创建一个范围。Class&lt;? extends Number&gt; 代码：J-P-321 向Class引用添加泛型语法的原因仅仅是为了提供编译期类型，因此如果你操作有误，稍后立即就会发现这一点。在使用普通Class引用，你不会误入歧途，但是如果你确实犯了错误，那么直到运行时你才会发现这一它，而这显得很不方便。 代码：J-P-321（566）","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Java编程思想","slug":"Java编程思想","permalink":"http://yoursite.com/tags/Java编程思想/"},{"name":"类型信息","slug":"类型信息","permalink":"http://yoursite.com/tags/类型信息/"}]},{"title":"二叉树的创建与遍历","slug":"二叉树的创建与遍历","date":"2019-12-09T13:31:03.000Z","updated":"2019-12-09T14:02:31.170Z","comments":true,"path":"2019/12/09/二叉树的创建与遍历/","link":"","permalink":"http://yoursite.com/2019/12/09/二叉树的创建与遍历/","excerpt":"二叉树的结构定义 使用Java进行二叉树的建立与遍历 class TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(int x){val = x;} }","text":"二叉树的结构定义 使用Java进行二叉树的建立与遍历 class TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(int x){val = x;} } 二叉树的建立 利用栈进行先序创建二叉树 //利用栈先序创建二叉树 TreeNode creatTree(List&lt;Integer&gt; nums) { Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode root = null; TreeNode parent = null; boolean lIsNull = false; TreeNode p = null; for(Integer i:nums) { //判断是否已经创建完根节点 if(root == null) { p = new TreeNode(i); root = p; parent = p; stack.push(p); }else if(i != null) { //输入的节点为null p = new TreeNode(i); if(lIsNull) { //创建完左孩子，且为null parent.right = p; parent = p; lIsNull = false; }else {//未创建左孩子 parent.left = p; parent = p; } stack.push(p); }else { if(lIsNull) {//左孩子为空，且右孩子也为空 if(stack.isEmpty()) {//如果栈为空，便是最后一个节点 return root; }else {// 返回为为空节点的双亲的双亲 parent = stack.pop(); } }else {//节点为空，令左孩子为null，返回为其双亲， //且使标记lIsNull为true，表示左孩子为空 parent = stack.pop(); lIsNull = true; } } } return root; }先序遍历二叉树 使用递归 /* * 二叉树的先序遍历 */ //使用递归先序遍历二叉树 public void preOrderTraverse1(TreeNode root) { if(root != null) { System.out.print(root.val); preOrderTraverse1(root.left); preOrderTraverse1(root.right); } } 使用栈 //使用栈先序遍历二叉树 public void preOrderTraverse2(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode p = root; while(p != null || !stack.isEmpty()) { if(p != null) { System.out.print(p.val); stack.push(p); p = p.left; }else { p = stack.pop(); p = p.right; } } }中序遍历二叉树 使用递归 /* * 二叉树的中序遍历 */ //使用递归进行中序遍历二叉树 public void inOrderTraverse1(TreeNode root) { if(root != null) { inOrderTraverse1(root.left); System.out.print(root.val); inOrderTraverse1(root.right); } } 使用栈 //使用栈进行中序遍历二叉树 public void inOrderTraverse2(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while(root != null || !stack.isEmpty()) { if(root != null) { stack.push(root); root = root.left; }else { root = stack.pop(); System.out.print(root.val); root = root.right; } } }中序遍历二叉树 使用递归 /* * 二叉树的后序遍历 */ //使用递归进行后序遍历二叉树 public void postOrderTraverse1(TreeNode root) { if(root != null) { postOrderTraverse1(root.left); postOrderTraverse1(root.right); System.out.print(root.val); } } 使用栈 //使用栈进行后序遍历二叉树 public void postOrderTraverse2(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while(root != null || !stack.isEmpty()) { if(root != null) { //使每个节点入栈两个，从而达到后序输出根节点 stack.push(root); stack.push(root); root = root.left; }else { root = stack.pop(); //根据栈顶元素判断是遍历弹栈还是输出根节点弹栈 if(!stack.isEmpty() &amp;&amp; root.val == stack.peek().val){ root = root.right; }else { System.out.print(root.val); root = null; } } } }层次（广度）遍历mainpublic class Solution { public static void main(String[] args) { List&lt;Integer&gt; nums = Arrays.asList(1,2,null,3,null,null,4,null,5,null,null); TreeNode root = new TreeNode(-1); root = root.creatTree(nums); //先序遍历 root.preOrderTraverse1(root); System.out.println(); root.preOrderTraverse2(root); System.out.println(); //中序遍历 root.inOrderTraverse1(root); System.out.println(); root.inOrderTraverse2(root); System.out.println(); //后序遍历 root.postOrderTraverse1(root); System.out.println(); root.postOrderTraverse2(root); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/二叉树/"}]},{"title":"哈夫曼编码","slug":"哈夫曼编码","date":"2019-11-23T01:24:47.000Z","updated":"2019-12-09T13:35:38.487Z","comments":true,"path":"2019/11/23/哈夫曼编码/","link":"","permalink":"http://yoursite.com/2019/11/23/哈夫曼编码/","excerpt":"哈夫曼编码哈夫曼编码可以很有效地压缩数据：通常可以节省20%~90%的空间，具体压缩率依赖于数据的特性。","text":"哈夫曼编码哈夫曼编码可以很有效地压缩数据：通常可以节省20%~90%的空间，具体压缩率依赖于数据的特性。 哈夫曼编码 假定我们希望压缩一个十万个字符的数据文件，下表给出了文件中所出现的字符和他们所出现的频率。 a b c d e f 频率（千次） 45 13 12 16 9 5 定长编码 000 001 010 011 100 101 变长编码 0 101 100 111 1101 1100 采用一种二进制字符编码，每个字符用一个唯一的二进制串表示，称为码字。 定长编码：需要用3位来表示6个字符，如上表定长编码所示，这种方式需要300000个二进制位来编码文件。 变长编码（variable-length code）：可以达到比定长编码好得多的压缩率，其思想是赋予高频字符短码字，赋予低频字符长码字。如上表变长编码所示。，这种编码表示共需224000位，比定长编码节约了25%的空间。 前缀码(prefix code）：即没有任何码字是其他码字的前缀。前缀码的作用是简化解码过程。由于没有码字是其他码字的前缀，编码文件的开始码字是无歧义的。我们可以简单的识别出开始码字，将其转换回原字符，然后对编码文件剩余部分重复这种解码过程。 哈夫曼树前缀码的一种方便的表示形式，可以容易地截取开始码字。一种二叉树，其叶节点为给定的字符。字符的二进制码字用从根节点到该字符叶节点的简单路径表示，其中0意味着“转向左孩子”，1意味着“转向右孩子”。注意：编码树并不是二叉搜索树，因为叶节点并未有序排列，而内部节点并不包含字符关键字。mermaid graph TB client--&gt;|2 findConfigServices|LoadBalancer; LoadBalancer--&gt;|3 findService|metaServer; metaServer--&gt;Eureka; client--&gt;|4 access via ip:port/client load balance/error retry|ConfigService; ConfigService--&gt;|1 register/cancel|Eureka; ConfigService--&gt;|read/write|ConfigDB;​","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"哈夫曼编码","slug":"哈夫曼编码","permalink":"http://yoursite.com/tags/哈夫曼编码/"}]},{"title":"Java杂记","slug":"Java杂记","date":"2019-11-17T11:23:19.000Z","updated":"2019-12-09T13:36:17.355Z","comments":true,"path":"2019/11/17/Java杂记/","link":"","permalink":"http://yoursite.com/2019/11/17/Java杂记/","excerpt":"操作符指数记数法 1.39E-43：其中e并不代表自然对数的基数（约等于2.718），而是“10的幂次”。","text":"操作符指数记数法 1.39E-43：其中e并不代表自然对数的基数（约等于2.718），而是“10的幂次”。 移位操作符 移位操作符的运算对象是二进制的“位”。 移位操作符只可用来处理整数类型（基本类型的一种）。 左移位操作符（&lt;&lt;）：能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0） 有符号”右移位操作符（&gt;&gt;）：按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。 Java中增加了一种“无符号”右移位操作符（&gt;&gt;&gt;），它使用“零扩展”：无论正负，都在高位插入0。这一操作符在C或C++中是没有的。 如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，他们会被转换为int类型，并且得到的结果也是一个int类型的值。只有数值右端的低5位才有用，这样可防止我们移位超过int型值所具有d额位数。（译注：因为2的5次方为32，而int型值只有32位）若对一个long类型的数值进行处理，最后得到的结果也是long。此时只会用到数值右端的低6位，以防止移位超过long型数值具有的位数。 “移位”可与“等号”（&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=）组合使用。注意：如果对byte或short值进行这样的移位运算，得到的可能不是正确的结果，他们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"操作符","slug":"操作符","permalink":"http://yoursite.com/tags/操作符/"}]},{"title":"Java Virtual Machine-自动内存管理机制（内存区域）","slug":"Java Virtual Machine-自动内存管理机制（内存区域）","date":"2019-11-11T07:50:15.000Z","updated":"2019-11-14T14:06:39.086Z","comments":true,"path":"2019/11/11/Java Virtual Machine-自动内存管理机制（内存区域）/","link":"","permalink":"http://yoursite.com/2019/11/11/Java Virtual Machine-自动内存管理机制（内存区域）/","excerpt":"概述与C/C++不同，Java拥有虚拟机自动内存管理机制，不需要为new的每一个对象都去写向对应的delect/free，从而不容易出现内存泄露和内存溢出问题。不过，也因Java程序员将内存控制的权利交给了Java虚拟机，一旦出现内存泄露和溢出的问题，如果不了解虚拟机是如何使用内存的，那么将很难排查错误。","text":"概述与C/C++不同，Java拥有虚拟机自动内存管理机制，不需要为new的每一个对象都去写向对应的delect/free，从而不容易出现内存泄露和内存溢出问题。不过，也因Java程序员将内存控制的权利交给了Java虚拟机，一旦出现内存泄露和溢出的问题，如果不了解虚拟机是如何使用内存的，那么将很难排查错误。 Java运行时数据区 由线程共享的数据区 线程隔离的数据区 方法区（Method Area) 虚拟机栈（VM Stack） 堆（Heap） 本地方法栈（Native Method Stack） 程序计数器（Program Counter Register） 程序计数器（Program Counter Register）线程私有的 定义：程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。 作用：由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，因此在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。所以为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，且各线程之间计数器互不影响，独立存储，我们称这片内存区域为“线程私有”的内存。 线程计数器：线程正在执行一个Java方法—-》计数器记录的是正在执行的虚拟机字节码指令的地址。线程正在执行一个Native方法–》计数器值为空（Undefined） 注：此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈（Java Virtual Machine Stack）线程私有的 生命周期与线程相同。 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表：存放了编译期可知的各种基本数据类型（boolean、byte、short、int、long、float、double、char）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用两个局部变量空间（Slot），其余的数据类型只占用一个。 局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。PS：栈帧：是方法运行时的基础数据结构。 注：会抛出StackOverflowError异常，如果扩展时无法申请到足够的内存，就会抛出会抛出OutOfMemoryError异常。 本地方法栈（Native Method Stack）线程私有的本地方法栈所发挥的作用与虚拟机栈的作用非常相似。两者之间的区别： 虚拟机栈：为虚拟机执行Java方法（也就是字节码）服务 本地方法栈：为虚拟机使用到的Native方法服务虚拟机规范中并未对本地方法栈中方法使用的语言、使用方式与数据结构进行强制规定，因此具体的虚拟机可以自由实现它。 如Sun HotSpot虚拟机直接将本地方法栈与虚拟机栈合二为一。 注：与虚拟机栈一样，也会抛出StackOverflowError异常和OutOfMemoryError异常。 Java堆（Java Heap）线程共享的 是Java虚拟机所管理的内存中最大的一块，在虚拟机启动时创建。 唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配。Java虚拟机规范中的描述：The heap is the runtime data area from which memory for all class instances and arrays is allocated.(所有的对象实例及数组都要在对上分配。）不过随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。 Java堆根据收集器所使用的的分代收集算法，还可进行分类，如新生代、老生代等。 Java堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可。 注：如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区（Method Area)线程共享的 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 垃圾收集较少，内存回收目标主要是针对常量池的回收和对类型的卸载。 注：当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。运行时常量池（Runtime Constant Pool） 方法区的一部分 Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 具备动态性，运行期间也可能将新的常量放入池中，如String类的intern（）方法。 注：当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域 这部分内存也被频繁使用，并且也可能导致OutOfMemoryError异常。 不会受到Java堆大小的限制。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"内存","slug":"内存","permalink":"http://yoursite.com/tags/内存/"}]},{"title":"数据库查询语句-select","slug":"数据库查询语句-select","date":"2019-11-11T07:50:15.000Z","updated":"2019-11-12T10:01:10.663Z","comments":true,"path":"2019/11/11/数据库查询语句-select/","link":"","permalink":"http://yoursite.com/2019/11/11/数据库查询语句-select/","excerpt":"查询SELECT（select）","text":"查询SELECT（select） 1.为表起别名（建议不要起中文）select * from 表名 as 别名 --》as可以省略 select 表名.列名1 列名2 from 表名2.查询全部列（*），指定列（列名），为列起别名as3.查询前n部分数据： top n 列名：表示查看前n行 select top 1 * from 表名 --》查询第一行 top n percent 列名：表示查看前百分之n的数据 selsct top 2 percent * from 表名 --》查询前2%的行4.排序：order by 列名1 asc|desc，列名1 asc|desc、、、(asc-升序|desc-降序)selsct top 2 percent * from 表名 order by 列名1 asc，列名2 desc --》先以列1按升序排，相同的再按列2按降序排 消除重复行：distinct select distinct 列名 from 表名 --》需要将列隔开，而不是利用*针对所有列 5.条件查询：写在where后面 对行进行筛选，返回bool类型的值 比较运算符：=，&gt;，&gt;=，&lt;，&lt;=，!=，&lt;&gt; select 列名 from 表名 where 列名=条件 between…and…：表示在一个连续的范围内 --取出编号从3-8的数据 select * from 表名 where 列名 between 3 and 8 in：表示在一个非连续的范围内 --取出编号为1或3的数据 select * from 表名 where 列名 in（1,3） 逻辑运算符：and，or，not 模糊查询：用于处理字符串类型的值，运算符包括（类似于正则表达式）：“like”(关键字) “%”(表示0到多个字符) “_” （表示一个字符）“[]”（表示从一个范围内选一个字符） “^”。 “%”与“_”写在“[]”中表示本身的含义在“[]”表示一个连续的范围可以使用“-”“^”写在“[]”内部的开头，表示不使用内部的任何字符。 --姓名为张的数据 select * from 表名 where name like &apos;张%&apos; null的判断：使用is null或is not null --列1为null的数据 select * from 表名 where 列1 is （not） null 优先级：小括号&gt;not&gt;比较运算符&gt;逻辑运算符 6.连接：join 表名 on 关联条件（连接查询：当需要的结果从多张表中取时） 左表 …join 右表 内连接：innew join，两表中完全匹配的数据。 select * from 表1 as 别名1 ` inner join 表2 as 别名2 on 别名1.列1=别名2.列1 左外连接：left outer join，两表中完全匹配的数据，左表中特有的数据。 右外连接：right outer join，两表中完全匹配的数据，右表中特有的数据。 完全外连接：full outer join，两表中完全匹配的数据，左表中特有的数据，右表中特有的数据。 -关键问题：哪些表行，关系 7.聚合函数：对数据进行合并。 sum（求和） avg（平均） count（计数) max（最大） min（最小）一般是对数字类型的列进行操作一条查询中可以同时写多个聚合函数，但是不能与普通列混写聚合中的null问题：不参与计算 select COUNT（*） as count from 表名 （where 列名=条件）8.开窗函数over（）将统计出来的数据分布到原表的每一行中结合聚合函数、排名函数使用 --将统计信息分布到每一行中去 select * avg(列名） over（） from 表名9.分组group by 列名1 列名2…聚合函数一般结合分组使用，进行分组内的数据进行统计根据指定列进行分组分组后条件筛选：having… --统计男女生人数 select 列名1 count（*） --》只能显示分组那一列 from 表名 where 列名1=条件 --》where语句写在分组前 group by 列名1 --》可以进行多级分组，只需在后面加“,列名2...” having count（*）&gt;条件 --》对分组之后的数据进行筛选总结：完整的select语句及执行顺序select distinct top n * from 表名1 join 表名2 on...join..表名n.. where ... group by...having... oder by...","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"},{"name":"查询","slug":"查询","permalink":"http://yoursite.com/tags/查询/"}]},{"title":"数据库脚本操作","slug":"数据库脚本操作","date":"2019-11-08T08:48:36.000Z","updated":"2019-11-12T06:02:11.897Z","comments":true,"path":"2019/11/08/数据库脚本操作/","link":"","permalink":"http://yoursite.com/2019/11/08/数据库脚本操作/","excerpt":"脚本操作","text":"脚本操作 不区分大小写，字符串使用单引号，末尾不需要加分号 按照功能分类 DDL：数据定义语言，用于进行各种数据库对象的创建，主要操作包括create（创建）、alter（修改）、drop（删除）。 DML：数据管理语言，用于对表数据的添加、修改、删除、查询，主键操作包括insert（插入）、update（修改）、delete(删除）、select（查询）。 DCL：数据控制语言，用于进行权限分配等。 注释：–单行注释，/**/多行注释 数据库：创建、删除 可以通过查看master数据库中的sysdatabases表，来了解当前存在的数据库。 创建数据库create database 数据库名 on primary ( name=&apos;stuDB_data&apos;,--主数据文件的逻辑名称 filename=&apos;D:\\stuDB_data.mdf&apos;,--主数据文件的物理名称 size=5mb,--主数据文件的初始大小 maxsize=100mb,--主数据文件增长的最大值 filegrowth=15%--主数据文件的增长率 ) log on ( name=&apos;stuDB_log&apos;, filename=&apos;D:\\stuDB_log.ldf;, size=2mb, filegrowth=1mb )创建表use 数据库名 create table 表名 ( 列名 int not null primary key identity(1,1), 列名 nvarchar(10) )","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"脚本语法","slug":"脚本语法","permalink":"http://yoursite.com/tags/脚本语法/"}]},{"title":"数据库语句学习","slug":"数据库语句学习","date":"2019-11-07T07:34:52.000Z","updated":"2019-11-12T06:02:28.280Z","comments":true,"path":"2019/11/07/数据库语句学习/","link":"","permalink":"http://yoursite.com/2019/11/07/数据库语句学习/","excerpt":"SQL基本命令","text":"SQL基本命令 SELECT(select)：查看数据库中的数据。 UPDATA（updata）：更新数据库中的数据。 DELETE（delect）：从数据库中删除数据。 INSERT INTO(insert into)：向数据库中插入新数据。 CREATE DATABASE(create database）：创建新数据库。 ALTER DATABASE(alter database）：修改数据库。 CREATE TABLE(create Table）：创建新表。 ALTER TABLE(alter Table）：变更数据库表。 DROP TABLE(drop table）：删除表。 CREATE INDEX(create index）：创建索引（搜索键）。 DROP INDEX(drop index）：删除索引。 示例数据库student表： id name score 1 张三 60 2 李四 60 3 王五 61 4 小六 62 1.SELECT（select）语句：显示某几列的数据： SELECT column_name,column_name FROM table_name; SELECT name,score FROM student;以及显示表中的全部列的数据： SELECT * FROM table_name; SELECT * FROM student;SELECT DISTINCT:返回唯一不同的值（所有有重复的项只会返回一个值）。 SELECT DISTINCT column_name，column_name FROM table_name； SELECT DISTINCT score FROM student;2.WHERE(where）语句：用于提取（筛选）那些满足指定条件的记录。 SELECT column_name,column_name FROM table_name WHERE column_name operator value;利用WHERE语句从student表中选取姓名为张三的所有学生： SELECT * FROM Websites WHERE name=&apos;张三&apos;;WHERE语句中的运算符： 运算符 描述 = 等于 &lt;&gt; 不等于。注释：在SQL的一些版本中，该操作符可被写成！= &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 is null 空值判断 BETWEEN 在某个范围内 LIKE 搜索某种模式（正则表达式） IN 指定针对某个列的多个可能值 PS:文本字段&amp;数值字段：SQL使用单引号来环绕文本值（大部分数据库系统也接收双引号），上述代码中使用了单引号。如果是数值字段，则不用使用引号。###","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"Linux-链接","slug":"Linux-链接","date":"2019-10-24T03:05:59.000Z","updated":"2019-12-09T13:35:20.103Z","comments":true,"path":"2019/10/24/Linux-链接/","link":"","permalink":"http://yoursite.com/2019/10/24/Linux-链接/","excerpt":"Linux链接在Linux中链接分为两种，一种为硬链接（Hard Link），另外一种为软链接（Symbolic Link）或称为符号链接。默认情况下，ln命令产生硬链接。","text":"Linux链接在Linux中链接分为两种，一种为硬链接（Hard Link），另外一种为软链接（Symbolic Link）或称为符号链接。默认情况下，ln命令产生硬链接。 硬链接：硬链接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号（Inode Index），它存储着文件重要参数信息，也就是元数据（metadata），比如创建时间、修改时间、文件大小、属主、归属的用户组（属组）、读写权数据所在block号等。在Linux中，多个文件名指向同一索引节点是存在的。比如：A是B的硬链接（A和B均为文件名），则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的链接。只删除一个链接并不影响索引节点本身和其他的链接，只有当最后一个链接被删除后，文件的数据块及目录的链接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除。 软链接：软链接（符号链接），类似于windows系统中的快捷方式。它实际上是一种特殊的文件。在符号链接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A任然存在（因为两个是不同的文件），但指向的是一个无效的链接。 两者的特点软链接： 1.软链接是存放另一个文件的路径的形式存在。 2.软链接可以跨文件系统，硬链接不行。 3.软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。 4.软链接可以对目录进行链接。 硬链接： 1.硬链接，以文件副本的形式存在。但不占用实际空间。 2.不允许给目录创建硬链接。 3.硬链接只有在同一个文件系统中才能创建。 4.删除一个硬链接文件并不影响其他有相同inode号的文件。 不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁盘空间。 Linux系统可以用ln命令来创建链接文件。 ln命令格式：ln [参数] [源文件或目录] [目标文件或目录] 主要参数： -i交互模式，文件存在则提示用户是否覆盖。 -s软链接（符号链接） -d允许超级用户制作目录的硬链接 -b删除，覆盖以前建立的链接 软链接（符号链接）：ln -s source target 硬链接（实体链接）：ln source target songguojun:https://www.cnblogs.com/songgj/p/9115954.html PS：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"链接","slug":"链接","permalink":"http://yoursite.com/tags/链接/"}]},{"title":"Redis初学","slug":"Redis初学","date":"2019-10-22T02:22:10.000Z","updated":"2019-11-12T06:03:28.912Z","comments":true,"path":"2019/10/22/Redis初学/","link":"","permalink":"http://yoursite.com/2019/10/22/Redis初学/","excerpt":"简介：","text":"简介： Redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库 特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式。 Redis数据类型：redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）以及zset（sorted set：有序集合）。 1.String（字符串） String类型是二进制安全的。即Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。 string类型的值最大能存储512MB。2.Hash（哈希） Redis hash是一个键值（key=&gt;value）对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 每个hash可以存储26 PS： Redis配置文件：位于Redis安装目录下，文件名为rredis.conf（windows名为redis.windows.conf）。可以通过CONFIG命令查看或设置配置项。 守护进程（Daemon Process），即Daemon进程（精灵进程），是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在Linux中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依赖于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。·","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"归并排序","slug":"归并排序","date":"2019-09-07T11:48:38.000Z","updated":"2019-11-12T06:03:01.248Z","comments":true,"path":"2019/09/07/归并排序/","link":"","permalink":"http://yoursite.com/2019/09/07/归并排序/","excerpt":"介绍：","text":"介绍： 描述：算法图解： 代码实现：12","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"插入排序","slug":"插入排序","date":"2019-09-06T14:05:55.000Z","updated":"2019-11-12T06:03:17.865Z","comments":true,"path":"2019/09/06/插入排序/","link":"","permalink":"http://yoursite.com/2019/09/06/插入排序/","excerpt":"介绍：","text":"介绍： 插入排序是将n个数的一个序列&lt;a1,a2,a3,…,an&gt;,经过插入排序算法将这n个数按序排列，输出满足a1&lt;a2&lt;a3&lt;…&lt;an。 描述：插入算法的工作方式如同人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入到左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较，并进行插入。拿在手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。 算法图解： 代码实现：12345678910111213public int [] insertSort(int [] nums) &#123; int key=0,j; for(int i=1;i&lt;nums.length;i++) &#123; key = nums[i]; j = i-1; while(j &gt;= 0 &amp;&amp; nums[j] &gt; key) &#123;//当j到达第一个数时，或者插入值找到位置时退出循环 nums[j+1] = nums[j]; j = j-1; &#125; nums[j+1] = key; &#125; return nums; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-09-06T01:05:53.000Z","updated":"2019-09-06T01:47:22.096Z","comments":true,"path":"2019/09/06/我的第一篇博客/","link":"","permalink":"http://yoursite.com/2019/09/06/我的第一篇博客/","excerpt":"","text":"","categories":[],"tags":[{"name":"My","slug":"My","permalink":"http://yoursite.com/tags/My/"}]}]}